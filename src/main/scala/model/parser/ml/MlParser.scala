package model.parser.ml;

import model.expression.*
import model.expression.Expression._
import model.parser.grammar._
import model.parser.template._
import model.parser.template.Tokenized._
import model.parser.util._
import model.parser.util.GrammarTree._
import model.parser.util.TypeOps._
import model.parser.template.AbstractLexer.LexerParams

/** GENERATED BY CUSTOM PARSER GENERATOR FROM MT COURSE (thanks [[https://codeforces.com/profile/andrewzta @andrewzta]])
  */

import cats.Monad
import cats.data.{EitherT, StateT}
import model.parser.ml.MlParser._

import java.io.InputStream

case class MlParser[F[_]: Monad](inputStream: InputStream) {
  private type MlMET[A] = MkContainer[MET, F]#Cont[A]
  type MlParseState[A]  = ParseState[F, MlLexer, A]
  val lex: MlLexer = MlLexer(
    inputStream,
    MlLexer(inputStream, LexerParams(TokenizedEmpty, 0, 0, -2))
      .nextToken()
      .getOrElse(LexerParams(TokenizedEmpty, 0, 0, -2)),
  )

  def otherCont(fromTerm: Expression): MlParseState[OtherContContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (
          lex.curTokenIn(
            Set(MlToken.MUL, MlToken.LT, MlToken.DIV, MlToken.SUB, MlToken.EQ_CMP, MlToken.GT, MlToken.ADD),
          )
        ) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            b        <- binOp()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => b :: list)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)

            // USER CODE
            res = BinaryOpTerm(b.res, fromTerm, e.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield OtherContContext("otherCont", children.reverse, res)
        } else if (
          lex.curTokenIn(
            Set(
              MlToken.SND,
              MlToken.VAR,
              MlToken.BOOL,
              MlToken.LET,
              MlToken.NUMBER,
              MlToken.OPEN_PAIR,
              MlToken.LPAREN,
              MlToken.FUN,
              MlToken.IF,
              MlToken.FST,
            ),
          )
        ) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            a        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => a :: list)

            // USER CODE
            res = AppTerm(fromTerm, a.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield OtherContContext("otherCont", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, OtherContContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def pairExpr(): MlParseState[PairExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.OPEN_PAIR))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            o        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.OPEN_PAIR)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected OPEN_PAIR, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e1       <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e1 :: list)
            c        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.COMMA)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected COMMA, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e2       <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e2 :: list)
            c2       <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.CLOSE_PAIR)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected CLOSE_PAIR, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = PairTerm(e1.res, e2.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield PairExprContext("pairExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, PairExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def letQrec(): MlParseState[LetQrecContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.LET))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            l        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.LET)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected LET, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            r        <- qRec()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => r :: list)

            // USER CODE
            res = l.text + r.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield LetQrecContext("letQrec", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, LetQrecContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def ifExpr(): MlParseState[IfExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.IF))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            i        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.IF)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected IF, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            cond     <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => cond :: list)
            t        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.THEN)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected THEN, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            thenExpr <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => thenExpr :: list)
            e        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.ELSE)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected ELSE, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            elseExpr <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => elseExpr :: list)

            // USER CODE
            res = CondTerm(cond.res, thenExpr.res, elseExpr.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield IfExprContext("ifExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, IfExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def qRec(): MlParseState[QRecContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.REC))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            r        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.REC)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected REC, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = r.text
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield QRecContext("qRec", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.VAR))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)

            // USER CODE
            res = ""
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield QRecContext("qRec", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, QRecContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def funcExpr(): MlParseState[FuncExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.FUN))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            f        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.FUN)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected FUN, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            v        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.VAR)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected VAR, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            a        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.ARROW)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected ARROW, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)

            // USER CODE
            res = FuncTerm(v.text, e.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield FuncExprContext("funcExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, FuncExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def otherExpr(): MlParseState[OtherExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.BOOL, MlToken.NUMBER, MlToken.VAR, MlToken.LPAREN))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            t        <- term()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => t :: list)
            cont     <- otherQcont(t.res)
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => cont :: list)

            // USER CODE
            res = cont.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield OtherExprContext("otherExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, OtherExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def letQrecExpr(): MlParseState[LetQrecExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.LET))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            l        <- letQrec()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => l :: list)
            v        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.VAR)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected VAR, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            assn     <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.EQ)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected EQ, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState  <- getLexerWithNextToken(curState)
            valueExpr <- expr()
            curState  <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => valueExpr :: list)
            i         <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer     <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.IN)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected IN, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            inExpr   <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => inExpr :: list)

            // USER CODE
            res =
              if (l.res == "letrec") LetRecTerm(v.text, valueExpr.res, inExpr.res)
              else LetTerm(v.text, valueExpr.res, inExpr.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield LetQrecExprContext("letQrecExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, LetQrecExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def binOp(): MlParseState[BinOpContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.MUL))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            m        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.MUL)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected MUL, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Mul
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.GT))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            g        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.GT)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected GT, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Gt
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.LT))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            l        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.LT)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected LT, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Lt
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.ADD))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            a        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.ADD)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected ADD, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Add
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.SUB))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            s        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.SUB)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected SUB, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Sub
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.DIV))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            d        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.DIV)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected DIV, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Div
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.EQ_CMP))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            e        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.EQ_CMP)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected EQ_CMP, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BinaryOperation.Eq
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield BinOpContext("binOp", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, BinOpContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def term(): MlParseState[TermContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.BOOL))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            b        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.BOOL)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected BOOL, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = BooleanTerm(b.text == "True")
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield TermContext("term", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.NUMBER))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            n        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.NUMBER)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected NUMBER, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = IntTerm(n.text.toInt)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield TermContext("term", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.VAR))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            v        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.VAR)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected VAR, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = VarTerm(v.text)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield TermContext("term", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.LPAREN))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            l        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.LPAREN)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected LPAREN, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)
            r        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.RPAREN)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected RPAREN, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = e.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield TermContext("term", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, TermContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def fstExpr(): MlParseState[FstExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.FST))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            f        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.FST)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected FST, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)

            // USER CODE
            res = UnaryOpTerm(UnaryOperation.Fst, e.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield FstExprContext("fstExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, FstExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def expr(): MlParseState[ExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.IF))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            i        <- ifExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => i :: list)

            // USER CODE
            res = i.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.FUN))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            f        <- funcExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => f :: list)

            // USER CODE
            res = f.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.LET))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            l        <- letQrecExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => l :: list)

            // USER CODE
            res = l.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.BOOL, MlToken.NUMBER, MlToken.VAR, MlToken.LPAREN))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            o        <- otherExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => o :: list)

            // USER CODE
            res = o.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.OPEN_PAIR))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            p        <- pairExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => p :: list)

            // USER CODE
            res = p.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.SND))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            snd      <- sndExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => snd :: list)

            // USER CODE
            res = snd.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else if (lex.curTokenIn(Set(MlToken.FST))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            fst      <- fstExpr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => fst :: list)

            // USER CODE
            res = fst.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ExprContext("expr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, ExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def sndExpr(): MlParseState[SndExprContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (lex.curTokenIn(Set(MlToken.SND))) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            s        <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.SND)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected SND, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)

            // USER CODE
            res = UnaryOpTerm(UnaryOperation.Snd, e.res)
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield SndExprContext("sndExpr", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, SndExprContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def otherQcont(fromTerm: Expression): MlParseState[OtherQcontContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (
          lex.curTokenIn(
            Set(
              MlToken.SND,
              MlToken.VAR,
              MlToken.DIV,
              MlToken.SUB,
              MlToken.LET,
              MlToken.EQ_CMP,
              MlToken.NUMBER,
              MlToken.OPEN_PAIR,
              MlToken.GT,
              MlToken.ADD,
              MlToken.LPAREN,
              MlToken.FUN,
              MlToken.MUL,
              MlToken.BOOL,
              MlToken.LT,
              MlToken.IF,
              MlToken.FST,
            ),
          )
        ) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            c        <- otherCont(fromTerm)
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => c :: list)

            // USER CODE
            res = c.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield OtherQcontContext("otherQcont", children.reverse, res)
        } else if (
          lex.curTokenIn(
            Set(MlToken.RPAREN, MlToken.THEN, MlToken.IN, MlToken.EOF, MlToken.COMMA, MlToken.CLOSE_PAIR, MlToken.ELSE),
          )
        ) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)

            // USER CODE
            res = fromTerm
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield OtherQcontContext("otherQcont", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, OtherQcontContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  def parse(): MlParseState[ParseContext] = {
    for {
      lex <- StateT.get[MlMET, MlLexer]
      res <-
        if (
          lex.curTokenIn(
            Set(
              MlToken.SND,
              MlToken.VAR,
              MlToken.BOOL,
              MlToken.LET,
              MlToken.NUMBER,
              MlToken.OPEN_PAIR,
              MlToken.LPAREN,
              MlToken.FUN,
              MlToken.IF,
              MlToken.FST,
            ),
          )
        ) {
          for {
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](List.empty)
            e        <- expr()
            curState <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState).map(list => e :: list)
            e1       <- StateT.get[MlMET, MlLexer].map(lexer => lexer.curToken())
            lexer    <- StateT.get[MlMET, MlLexer]
            _ <-
              if (!lexer.compareToken(MlToken.EOF)) {
                throwPEStateT[F, MlLexer, List[GrammarTree[_]]]("Expected EOF, found:" + lexer.curToken().text)
              } else {
                StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              }
            curState <- StateT
              .pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
              .map(list => TerminalTree(lexer.curToken()) :: list)
            curState <- getLexerWithNextToken(curState)

            // USER CODE
            res = e.res
            // END USER CODE

            children <- StateT.pure[MlMET, MlLexer, List[GrammarTree[_]]](curState)
          } yield ParseContext("parse", children.reverse, res)
        } else {
          throwPEStateT[F, MlLexer, ParseContext]("Unexpected token: " + lex.curToken())
        }
    } yield res
  }

  private def getLexerWithNextToken(curState: List[GrammarTree[_]]): MlParseState[List[GrammarTree[_]]] = {
    StateT.apply[MlMET, MlLexer, List[GrammarTree[_]]] { lexer =>
      lexer
        .nextToken()
        .fold(
          e => EitherT.leftT(e),
          params => EitherT.rightT((MlLexer(lexer.inputStream, params), curState)),
        )
    }
  }
}

object MlParser {

  case class OtherContContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): OtherContContext =
      OtherContContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): OtherContContext =
      OtherContContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class PairExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): PairExprContext = PairExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): PairExprContext =
      PairExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class LetQrecContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: String = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): LetQrecContext = LetQrecContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): LetQrecContext =
      LetQrecContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class IfExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): IfExprContext = IfExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): IfExprContext =
      IfExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class QRecContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: String = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): QRecContext  = QRecContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): QRecContext = QRecContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class FuncExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): FuncExprContext = FuncExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): FuncExprContext =
      FuncExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class OtherExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): OtherExprContext =
      OtherExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): OtherExprContext =
      OtherExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class LetQrecExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): LetQrecExprContext =
      LetQrecExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): LetQrecExprContext =
      LetQrecExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class BinOpContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: BinaryOperation = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): BinOpContext = BinOpContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): BinOpContext =
      BinOpContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class TermContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): TermContext  = TermContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): TermContext = TermContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class FstExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): FstExprContext = FstExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): FstExprContext =
      FstExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class ExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): ExprContext  = ExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): ExprContext = ExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class SndExprContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): SndExprContext = SndExprContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): SndExprContext =
      SndExprContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class OtherQcontContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): OtherQcontContext =
      OtherQcontContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): OtherQcontContext =
      OtherQcontContext(ctxRoot, ctxChildren ++ List(child))
  }

  case class ParseContext(ctxRoot: String, ctxChildren: List[GrammarTree[_]] = List.empty, res: Expression = null)
      extends ContextTree(ctxRoot, ctxChildren) {
    override def pushFirstChild(child: GrammarTree[_]): ParseContext = ParseContext(ctxRoot, child :: ctxChildren)
    override def appendLastChild(child: GrammarTree[_]): ParseContext =
      ParseContext(ctxRoot, ctxChildren ++ List(child))
  }
}
